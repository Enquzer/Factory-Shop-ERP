import bcrypt from 'bcryptjs';
import { getDb, resetDbCache } from './db';
import { createNotification } from './notifications';

export type ProductVariant = {
  id: string;
  productId: string;
  color: string;
  size: string;
  stock: number;
  imageUrl?: string;
};

export type AgePricing = {
  id?: number;  // Make id optional since it's auto-generated by the database
  productId: string;
  ageMin: number;
  ageMax: number;
  price: number;
};

export type Product = {
  id: string;
  productCode: string;
  name: string;
  category: string;
  price: number;
  minimumStockLevel: number;
  variants: ProductVariant[];
  agePricing?: AgePricing[];
  imageUrl?: string;
  description?: string;
  readyToDeliver?: number; // New field to control shop visibility
  updatedAt?: Date; // Add updatedAt field
};

export type AuthResult = {
  success: boolean;
  user?: User;
  message?: string;
};

export type User = {
  id: number;
  username: string;
  role: 'factory' | 'shop';
  createdAt: Date;
};

// Check if a product with the given product code already exists
export async function productCodeExists(productCode: string): Promise<boolean> {
  try {
    const db = await getDb();
    const result = await db.get(`
      SELECT 1 FROM products WHERE productCode = ?
    `, productCode.toUpperCase());
    return !!result;
  } catch (error) {
    console.error('Error checking if product code exists:', error);
    return false;
  }
}

// Get all products
export async function getProducts(): Promise<Product[]> {
  try {
    console.log('SQLite getProducts called');
    const db = await getDb();
    const products = await db.all(`
      SELECT * FROM products ORDER BY created_at DESC
    `);
    
    console.log('Products fetched from database:', products);
    
    const productsWithVariants = await Promise.all(
      products.map(async (product: any) => {
        const variants = await db.all(`
          SELECT * FROM product_variants WHERE productId = ?
        `, product.id);
        
        // Get age-based pricing
        const agePricing = await db.all(`
          SELECT * FROM product_age_pricing WHERE productId = ?
        `, product.id);
        
        // Use the product's own imageUrl, fallback to first variant's image if available
        const imageUrl = product.imageUrl || (variants.length > 0 ? variants[0].imageUrl : undefined);
        
        return {
          ...product,
          variants,
          agePricing,
          imageUrl,
          description: product.description,
          readyToDeliver: product.readyToDeliver || 0,
          createdAt: new Date(product.created_at),
          updatedAt: product.updated_at ? new Date(product.updated_at) : undefined
        };
      })
    );
    
    console.log('Products with variants:', productsWithVariants);
    return productsWithVariants;
  } catch (error) {
    console.error('Error fetching products:', error);
    return [];
  }
}

// Get a product by ID
export async function getProductById(id: string): Promise<Product | null> {
  try {
    const db = await getDb();
    
    // Get the product
    const product = await db.get(`
      SELECT * FROM products WHERE id = ?
    `, id);

    if (!product) {
      return null;
    }

    // Get the product variants
    const variants = await db.all(`
      SELECT * FROM product_variants WHERE productId = ?
    `, id);
    
    // Get age-based pricing
    const agePricing = await db.all(`
      SELECT * FROM product_age_pricing WHERE productId = ?
    `, id);

    // Use the product's own imageUrl, fallback to first variant's image if available
    const imageUrl = product.imageUrl || (variants.length > 0 ? variants[0].imageUrl : undefined);

    return {
      ...product,
      variants,
      agePricing,
      imageUrl,
      description: product.description,
      readyToDeliver: product.readyToDeliver || 0,
      updatedAt: product.updated_at ? new Date(product.updated_at) : undefined
    };
  } catch (error) {
    console.error('Error fetching product:', error);
    return null;
  }
}

// Create a new product
export async function createProduct(product: Omit<Product, 'id'>): Promise<Product> {
  try {
    // Get database connection
    const db = await getDb();
    
    // Check if product code already exists
    const exists = await productCodeExists(product.productCode);
    if (exists) {
      throw new Error(`Product with code "${product.productCode}" already exists`);
    }
    
    // Generate a simple ID (in a real app, you might want to use a more robust ID generation method)
    const productId = `PRD-${Date.now()}`;
    
    // Insert the product with readyToDeliver set to 1 by default
    await db.run(`
      INSERT INTO products (id, productCode, name, category, price, minimumStockLevel, imageUrl, description, readyToDeliver)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, productId, product.productCode.toUpperCase(), product.name, product.category, product.price, product.minimumStockLevel, product.imageUrl, product.description, 1);

    // Insert the variants
    const variants: ProductVariant[] = [];
    for (const variant of product.variants) {
      const variantId = `VAR-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      await db.run(`
        INSERT INTO product_variants (id, productId, color, size, stock, imageUrl)
        VALUES (?, ?, ?, ?, ?, ?)
      `, variantId, productId, variant.color, variant.size, variant.stock, variant.imageUrl);
      
      variants.push({
        id: variantId,
        productId,
        color: variant.color,
        size: variant.size,
        stock: variant.stock,
        imageUrl: variant.imageUrl
      });
    }
    
    // Insert age-based pricing if provided
    const agePricing: AgePricing[] = [];
    if (product.agePricing && product.agePricing.length > 0) {
      for (const pricing of product.agePricing) {
        const result = await db.run(`
          INSERT INTO product_age_pricing (productId, ageMin, ageMax, price)
          VALUES (?, ?, ?, ?)
        `, productId, pricing.ageMin, pricing.ageMax, pricing.price);
        
        agePricing.push({
          id: result.lastID ?? 0,
          productId,
          ageMin: pricing.ageMin,
          ageMax: pricing.ageMax,
          price: pricing.price
        });
      }
    }

    // Create notification for factory users
    try {
      await createNotification({
        userType: 'factory',
        title: 'New Product Added',
        description: `Product "${product.name}" has been added to the catalog`,
        href: `/products`,
      });
    } catch (notificationError) {
      console.error('Failed to create notification:', notificationError);
      // Don't throw here, we want the product creation to succeed even if notification fails
    }
    
    // Remove the automatic population of shop inventories
    // Shops will only get inventory when they actually order products
    
    // Reset the database cache to ensure subsequent queries get fresh data
    resetDbCache();
    
    return {
      id: productId,
      productCode: product.productCode.toUpperCase(),
      name: product.name,
      category: product.category,
      price: product.price,
      minimumStockLevel: product.minimumStockLevel,
      variants,
      agePricing,
      imageUrl: product.imageUrl || (variants.length > 0 ? variants[0].imageUrl : undefined),
      description: product.description,
      readyToDeliver: 1 // Set to 1 by default
    };
  } catch (error) {
    console.error('Error creating product:', error);
    throw error;
  }
}

// Update a product
export async function updateProduct(id: string, product: Partial<Product>): Promise<boolean> {
  try {
    console.log('updateProduct called with id:', id, 'and data:', product);
    
    // Get database connection
    const db = await getDb();
    
    // Get current product for audit logging and validation
    const currentProduct = await getProductById(id);
    if (!currentProduct) {
      console.error('Product not found with id:', id);
      throw new Error('Product not found');
    }
    
    console.log('Current product:', currentProduct);
    
    // Build dynamic update query based on provided fields
    const fields: string[] = [];
    const values: any[] = [];
    
    // Handle product fields if provided
    if (product.name !== undefined) {
      fields.push('name = ?');
      values.push(product.name);
    }
    if (product.productCode !== undefined) {
      fields.push('productCode = ?');
      values.push(product.productCode);
    }
    if (product.category !== undefined) {
      fields.push('category = ?');
      values.push(product.category);
    }
    if (product.price !== undefined) {
      fields.push('price = ?');
      values.push(product.price);
    }
    if (product.minimumStockLevel !== undefined) {
      fields.push('minimumStockLevel = ?');
      values.push(product.minimumStockLevel);
    }
    if (product.description !== undefined) {
      fields.push('description = ?');
      values.push(product.description || null);
    }
    if (product.imageUrl !== undefined) {
      fields.push('imageUrl = ?');
      values.push(product.imageUrl || null);
    }
    // Handle readyToDeliver field specifically
    if (product.readyToDeliver !== undefined) {
      console.log('Updating readyToDeliver field to:', product.readyToDeliver);
      fields.push('readyToDeliver = ?');
      values.push(product.readyToDeliver);
    }
    
    // Always update the updatedAt field
    fields.push('updated_at = CURRENT_TIMESTAMP');
    
    if (fields.length > 0) {
      values.push(id);
      const query = `UPDATE products SET ${fields.join(', ')} WHERE id = ?`;
      console.log('Executing product update query:', query, 'with values:', values);
      const result = await db.run(query, ...values);
      console.log('Product update result:', result);
      
      // Check if any rows were affected
      if (result.changes === 0) {
        console.warn('No rows were updated. Product may not exist or no changes were made.');
        // This isn't necessarily an error - it could mean no changes were needed
      }
    }

    // Handle variants if provided
    if (product.variants) {
      console.log('Updating variants:', JSON.stringify(product.variants, null, 2));
      
      // Get existing variants
      const existingVariants = await db.all(`
        SELECT id FROM product_variants WHERE productId = ?
      `, id);

      console.log('Existing variants:', existingVariants);
      const existingVariantIds = new Set(existingVariants.map((v: any) => v.id));
      const updatedVariantIds = new Set(product.variants.map(v => v.id));
      console.log('Existing variant IDs:', Array.from(existingVariantIds));
      console.log('Updated variant IDs:', Array.from(updatedVariantIds));

      // Delete variants that are no longer present
      for (const existingVariant of existingVariants) {
        if (!updatedVariantIds.has(existingVariant.id)) {
          console.log('Deleting variant:', existingVariant.id);
          const deleteResult = await db.run(`
            DELETE FROM product_variants WHERE id = ?
          `, existingVariant.id);
          console.log('Delete result:', deleteResult);
        }
      }

      // Insert or update variants
      for (const variant of product.variants) {
        console.log('Processing variant:', JSON.stringify(variant, null, 2));
        
        // Validate required fields only if they are present in the update
        if (variant.id === undefined) {
          console.error('Variant ID is required');
          throw new Error('Variant ID is required');
        }
        
        if (existingVariantIds.has(variant.id)) {
          // Update existing variant
          console.log('Updating existing variant:', variant.id);
          console.log('Variant data:', variant);
          
          // Build dynamic update query based on provided fields
          const variantFields: string[] = [];
          const variantValues: any[] = [];
          
          if (variant.color !== undefined) {
            variantFields.push('color = ?');
            variantValues.push(variant.color);
          }
          if (variant.size !== undefined) {
            variantFields.push('size = ?');
            variantValues.push(variant.size);
          }
          if (variant.stock !== undefined) {
            variantFields.push('stock = ?');
            variantValues.push(variant.stock);
          }
          if (variant.imageUrl !== undefined) {
            variantFields.push('imageUrl = ?');
            variantValues.push(variant.imageUrl || null);
          }
          
          if (variantFields.length > 0) {
            variantValues.push(variant.id);
            const variantQuery = `UPDATE product_variants SET ${variantFields.join(', ')} WHERE id = ?`;
            const updateResult = await db.run(variantQuery, ...variantValues);
            console.log('Update variant result:', updateResult);
          }
        } else {
          // Insert new variant
          // Only insert if all required fields are provided
          if (variant.color !== undefined && variant.size !== undefined && variant.stock !== undefined) {
            console.log('Inserting new variant:', variant.id);
            console.log('Variant data:', variant);
            
            const insertResult = await db.run(`
              INSERT INTO product_variants (id, productId, color, size, stock, imageUrl)
              VALUES (?, ?, ?, ?, ?, ?)
            `, variant.id, id, variant.color, variant.size, variant.stock, variant.imageUrl || null);
            console.log('Insert variant result:', insertResult);
          } else {
            console.warn('Skipping variant insert due to missing required fields:', variant);
          }
        }
      }
    }
    
    // Handle age-based pricing if provided
    if (product.agePricing) {
      console.log('Updating age-based pricing:', JSON.stringify(product.agePricing, null, 2));
      
      // Delete all existing age pricing for this product
      await db.run(`
        DELETE FROM product_age_pricing WHERE productId = ?
      `, id);
      
      // Insert new age pricing
      for (const pricing of product.agePricing) {
        await db.run(`
          INSERT INTO product_age_pricing (productId, ageMin, ageMax, price)
          VALUES (?, ?, ?, ?)
        `, id, pricing.ageMin, pricing.ageMax, pricing.price);
      }
    }

    // Create notification for factory users if product name exists
    if (currentProduct && currentProduct.name) {
      try {
        await createNotification({
          userType: 'factory',
          title: 'Product Updated',
          description: `Product "${currentProduct.name}" has been updated`,
          href: `/products`,
        });
      } catch (notificationError) {
        console.error('Failed to create update notification:', notificationError);
        // Don't throw here, we want the product update to succeed even if notification fails
      }
    }

    // Create notifications for shops that have any variant of this product in their inventory
    try {
      // Get all shops that have any variant of this product in their inventory
      const shopsWithProduct = await db.all(`
        SELECT DISTINCT si.shopId 
        FROM shop_inventory si 
        JOIN product_variants pv ON si.productVariantId = pv.id 
        WHERE pv.productId = ?
      `, id);
      
      console.log('Shops with this product in inventory:', shopsWithProduct);
      
      // Create notification for each shop
      for (const shop of shopsWithProduct) {
        await createNotification({
          userType: 'shop',
          shopId: shop.shopId,
          title: 'Product Updated',
          description: `Product "${currentProduct.name}" has been updated. Please check for changes in price, variants, or availability.`,
          href: '/shop/inventory',
        });
      }
    } catch (shopNotificationError) {
      console.error('Failed to create shop update notifications:', shopNotificationError);
      // Don't throw here, we want the product update to succeed even if shop notifications fail
    }

    console.log('Product update completed successfully');
    // Reset the database cache to ensure subsequent queries get fresh data
    resetDbCache();
    return true;
  } catch (error: any) {
    console.error('Error updating product:', error);
    console.error('Error stack:', error.stack);
    // Re-throw the error so the API route can catch it and provide detailed error information
    throw error;
  }
}

// Delete a product
export async function deleteProduct(id: string): Promise<boolean> {
  try {
    // Get database connection
    const db = await getDb();
    
    const result = await db.run(`
      DELETE FROM products WHERE id = ?
    `, id);
    const deleted = (result.changes || 0) > 0;
    if (deleted) {
      // Reset the database cache to ensure subsequent queries get fresh data
      resetDbCache();
    }
    return deleted;
  } catch (error) {
    console.error('Error deleting product:', error);
    return false;
  }
}

// Update variant stock (transaction handled at API level)
export async function updateVariantStock(variantId: string, newStock: number): Promise<boolean> {
  try {
    // Get database connection
    const db = await getDb();
    
    const result = await db.run(`
      UPDATE product_variants SET stock = ? WHERE id = ?
    `, newStock, variantId);
    const updated = (result.changes || 0) > 0;
    if (updated) {
      // Reset the database cache to ensure subsequent queries get fresh data
      resetDbCache();
    }
    return updated;
  } catch (error) {
    console.error('Error updating variant stock:', error);
    return false;
  }
}

// Update variant image (transaction handled at API level)
export async function updateVariantImage(variantId: string, imageUrl: string): Promise<boolean> {
  try {
    // Get database connection
    const db = await getDb();
    
    const result = await db.run(`
      UPDATE product_variants SET imageUrl = ? WHERE id = ?
    `, imageUrl, variantId);
    const updated = (result.changes || 0) > 0;
    if (updated) {
      // Reset the database cache to ensure subsequent queries get fresh data
      resetDbCache();
    }
    return updated;
  } catch (error) {
    console.error('Error updating variant image:', error);
    return false;
  }
}

// Update shop inventory when product stock is replenished
export async function updateShopInventoryOnReplenishment(productId: string, variantId: string, quantityAdded: number): Promise<boolean> {
  try {
    const db = await getDb();
    
    // Get the product and variant details for the notification
    const product = await db.get(`
      SELECT p.name, pv.color, pv.size 
      FROM products p 
      JOIN product_variants pv ON p.id = pv.productId 
      WHERE pv.id = ?
    `, variantId);
    
    if (!product) {
      console.error('Product or variant not found for replenishment notification');
      return false;
    }
    
    // Get all shops that have this product variant in their inventory
    const shopsWithVariant = await db.all(`
      SELECT shopId FROM shop_inventory WHERE productVariantId = ?
    `, variantId);
    
    let updated = false;
    // Update stock for each shop and create notifications
    for (const shop of shopsWithVariant) {
      // Update the shop's inventory
      const result = await db.run(`
        UPDATE shop_inventory 
        SET stock = stock + ? 
        WHERE shopId = ? AND productVariantId = ?
      `, quantityAdded, shop.shopId, variantId);
      
      if (result.changes > 0) {
        updated = true;
      }
      
      // Create notification for the shop
      await createNotification({
        userType: 'shop',
        shopId: shop.shopId,
        title: `Product Replenished`,
        description: `Product "${product.name}" (${product.color}, ${product.size}) has been replenished with ${quantityAdded} units. You can now place orders for this product.`,
        href: '/shop/inventory',
      });
    }
    
    if (updated) {
      // Reset the database cache to ensure subsequent queries get fresh data
      resetDbCache();
    }
    
    return true;
  } catch (error) {
    console.error('Error updating shop inventory on replenishment:', error);
    return false;
  }
}